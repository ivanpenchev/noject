/**
 * created by: Nikolai Aleksandrenko
 * email: aleksandrenko@gmail.com
 * www: aleksandrenko.com
 */

"use strict";

var models = require('./models.js'),
    Q = require('q'),
    schemes = require('./schemes.js'),
    db = require('./db.js'),
    neo4jApi = require('neo4j'),
    neo4j = new neo4jApi.GraphDatabase('http://localhost:7474'),
    validator = require('./validator.js');


/**
 * Creates a new model object will properties and methods
 * @param {string} modelType
 * @param {Object} scheme
 */
module.exports = function (modelType, scheme) {

    /**
     * Model Constructor
     * @param newNode
     */
    var model = function Model(newNode) {

        var self = this,
            data = {},
            /**
             * Private variable for saving neo4j node object
             * @type {string}
             * @private
             */
                type = '',
            /**
             * Private variable for saving neo4j node object
             * @type {Object}
             * @private
             */
                node,
            /**
             * Private variable for saving neo4j node object
             * @type {array}
             * @private
             */
                indexes = [],
            /**
             * Private variable for saving neo4j node object
             * @type {number}
             * @private
             */
                id = newNode.id;

        //==============================================================================================

        /**
         * id getter
         */
        this.__defineGetter__("id", function () {
            return id;
        });

        //==============================================================================================

        /**
         * type getter
         */
        this.__defineGetter__("type", function () {
            return type;
        });

        //==============================================================================================

        /**
         * data getter
         */
        this.__defineGetter__("data", function () {
            return data;
        });


        function setData(newData) {
            data = newData;
        }

        /**
         * data setter
         */
        this.__defineSetter__("data", function (val) {
            setData(val);
            //return true if validations is ok
            return true;
        });
        //==============================================================================================


        /**
         * Model's save function. Return success/error via promise.
         */
        this.save = function () {
            var deferred = Q.defer();

            //next tick so done and fail functions can be assigned
            process.nextTick(function () {
                if (node === undefined) {
                    p.triggerError('Model first must be created before saved.');
                } else {
                    node.save(function (err, node) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            id = node.id;
                            deferred.resolve();

                            //create INDEXES !!!
                            //console.log('=========================================');
                            //console.log(scheme);

                            indexes.forEach(function(index) {

                                node.index(index.name, index.key, index.value, function(err) {
                                    if(err) {
                                        //console.log('ERROR: Creating index error.');
                                        //console.log(err);
                                        //console.log('===================================================================');
                                    } else {
                                        //console.log(index);
                                    }
                                }, false);
                            });

                            //console.log('=========================================');
                        }
                    });
                }
            });

            return deferred.promise;
        };

        /**
         * Model's delete function Return success/error via promise.
         */
        this.del = function () {
            var deferred = Q.defer();

            //next tick so done and fail functions can be assigned
            process.nextTick(function () {
                if (node === undefined) {
                    p.triggerError('Model first must be created before deleted.');
                } else {
                    node.del(function (err, node) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            deferred.resolve();

                            //delete INDEXES !!!
                            //delete model instance
                        }
                    });
                }
            });

            return deferred.promise;
        };

        //here scheme must be looped and if user specified relationships methods must be added
        //model.getRelationships
        //model.addRelationship
        //model.removeRelationship

        /**
         * Create relationship methods
         */
        Object.keys(scheme).forEach(function (key) {
            //if there is and target ... this is an relationship
            var val = scheme[key];

            //if there is a target, noun and plural - it's relationship

            if (val.target && val.noun && val.plural) {
                //create methods for this relationship
                var getMethod = 'get' + val.plural[0].toUpperCase() + val.plural.slice(1),
                    addMethod = 'add' + val.noun[0].toUpperCase() + val.noun.slice(1),
                    removeMethod = 'remove' + val.noun[0].toUpperCase() + val.noun.slice(1);

                /**
                 * Getting related nodes
                 * TODO: DO FILTERING
                 * @param params
                 * @returns {Promise}
                 */
                self[getMethod] = function (params) {
                    var deferred = Q.defer();

                    node.getRelationshipNodes(val.type, function(err, nodes) {
                        if(err) {
                            deferred.reject(err);
                        } else {
                            var models = [];

                            nodes.forEach(function(node) {
                                models.push(new Model(node));
                                //console.log(node.id);
                            });

                            deferred.resolve();
                        }
                    });

                    //if params === undefined - get all
                    //if params !== undefined - filter by params

                    return deferred.promise;
                };

                /**
                 * Add relationship to a node
                 * @param endNodeId
                 */
                self[addMethod] = function (endNodeId) {
                    var deferred = Q.defer();

                    neo4j.getNodeById(endNodeId, function(err, endNode) {
                        if(err) {
                            console.log(err);
                            deferred.reject(err);
                        } else {

                            //Create relationship to end node
                            var relationshipData = {};
                            node.createRelationshipTo(endNode, val.type, relationshipData, function(err, relationship) {
                                if(err) {
                                    deferred.reject(err);
                                    console.log('Error creating the relationship.');
                                }

                                deferred.resolve();

                                //console.log('----------------------------------------');
                                //console.log('relationship:');
                                //console.log(relationship);
                                //console.log('----------------------------------------');
                            });
                        }
                    });

                    return deferred.promise;
                };

                /**
                 * Remove relationship to node
                 * @param endNodeId
                 */
                self[removeMethod] = function (endNodeId) {
                    var p = new Promise(),
                        startNodeId = id,
                        endNodeId = endNodeId,
                        relationshipType = val.type,
                        query = [
                            'START a=node(' + startNodeId + '), b=node(' + endNodeId + ')',
                            'MATCH a-[r:' + relationshipType + ']->b',
                            'DELETE r'
                        ].join('\n'),
                        params = {};

                    neo4j.query(query, params, function (err, results) {
                        if (err) {
                            p.triggerError(err);
                        } else {
                            p.triggerSuccess(results);
                        }
                    });

                    return p;
                };

            }

        });


        /**
         * Create properties setters and getters
         */
        Object.keys(scheme).forEach(function (key) {

            //if target is undefined the rule is NOT for relationship
            if (scheme[key].target === undefined) {

                /**
                 * type getter
                 */
                self.__defineGetter__(key, function () {
                    return data[key];
                });

                /**
                 * type setter
                 */
                self.__defineSetter__(key, function (val) {
                    //validate before save

                    if( validator.validateProperty(modelType, key, val) ) {;
                        data[key] = val;
                    } else {
                        console.log("ERROR: Value is not valid.");
                    }
                });

            }

        });


        /**
         * Disable adding new functions and properties from the alter on.
         */
        Object.preventExtensions(this);


        /**
         * Set Values
         */

        if (newNode) {
            if (newNode.data) {
                setData(newNode.data);
                node = newNode;
            } else {
                console.log('Trow error no, node data.');
            }
        } else {
            console.log('Trow error no, node.');
        }


        /**
         * Set Indexes
         */
        Object.keys(scheme).forEach(function(key) {

            if(scheme[key].index) {
                var index = {
                    name: modelType,
                    key: key,
                    value: data[key]
                };

                indexes.push(index);
            }
        });

        //add another index for node type
        var nodeIndex = {
            name: 'nodes',
            key: 'type',
            value: modelType
        };

        indexes.push(nodeIndex);
    };

    models.registerModel(modelType, model, scheme);
    schemes.registerModel(modelType, scheme);
    db.registerModel(modelType, model, scheme);
};
/*

 db.get node from server
 server node
 validirane na dannite po shemata na iskaniq model
 vzemane na edin model suzdaden po schema
 nabutvane na dannite ot syrvarniq model v nego
 opisvane na indeksite, koito se predpolaga che ima
 vrushtane na schema modela s dannite ot survara prez promise



 model.save na schema model
 validirane na dannite
 ako nqma opisani indeksi se suzdavat indeksi - sus server requests, ako ima opisani indeksi znachi ne e nov i e vzet ot survura
 vrushtane na success prez prommise



 model.getFriends
 request do survura s base index-a na modela (nodes:type:modelType) i relationshipa, ko poito se iskat
 cikul za
 validirane na dannite
 vzemane na edin model suzdaden po schema
 nabutvane na dannite ot syrvarniq model v nego
 opisvane na indeksite, koito se predpolaga che ima
 zapisvane v 1 masiv s scheme modeli



 model.deleteFriend(nodeid)
 vzemane na server node po nodeid
 premahvane an relationship-a kym krainiq survur node



 model.delete
 proverka dali ima indeksi
 ako nqma, znachi e tokushto suzdaden i ne zapisan
 ako ima, znachi e zapisvan i indeksite trqbva da se iztriqt zaedno s node-a
 iztrivane na indexes
 iztrivane na node
 */