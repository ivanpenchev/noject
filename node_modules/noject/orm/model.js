/**
 * created by: Nikolai Aleksandrenko
 * email: aleksandrenko@gmail.com
 * www: aleksandrenko.com
 */

"use strict";

var __models = require('./models.js'),
    __Q = require('q'),
    __schemes = require('./schemes.js'),
    __db = require('./db.js'),
    __neo4jApi = require('neo4j'),
    __neo4j = new __neo4jApi.GraphDatabase('http://localhost:7474'),
    __validator = require('./validator.js');

//TODO: Да направя поддръжка на уникални пропертита

/**
 * Creates a new model object will properties and methods
 * @param {string} modelType
 * @param {Object} scheme
 */
module.exports = function (modelType, scheme) {

    /**
     * Model Constructor
     * @param newNode
     */
    var model = function Model(newNode) {

        var _self = this,
            _data = {},
            /**
             * Private variable for saving neo4j node object
             * @type {string}
             * @private
             */
            _type = modelType,
            /**
             * Private variable for saving neo4j node object
             * @type {Object}
             * @private
             */
            _node,
            /**
             * Private variable for saving neo4j node object
             * @type {array}
             * @private
             */
            _indexes = [],
            /**
             * Private variable for saving neo4j node object
             * @type {number}
             * @private
             */
            _id = newNode.id;

        //==============================================================================================

        /**
         * id getter
         */
        _self.__defineGetter__("id", function () {
            return _id;
        });

        //==============================================================================================

        /**
         * type getter
         */
        _self.__defineGetter__("type", function () {
            return _type;
        });

        //==============================================================================================

        /**
         * data getter
         */
        _self.__defineGetter__("data", function () {
            return _data;
        });


        function _setData(newData) {
            /** TODO: validate before set **/
            _data = newData;
        }

        /**
         * data setter
         */
        _self.__defineSetter__("data", function (data) {
            _setData(data);
        });
        //==============================================================================================


        /**
         * Model's save function. Return success/error via promise.
         */
        _self.save = function () {
            var deferred = __Q.defer();

            //next tick so done and fail functions can be assigned
            process.nextTick(function () {
                if (_node === undefined) {
                    p.triggerError('Model first must be created before saved.');
                } else {
                    _node.save(function (err, _node) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            _id = _node.id;
                            deferred.resolve(_self);

                            //create INDEXES !!!
                            //console.log('=========================================');
                            //console.log(scheme);

                            _indexes.forEach(function (index) {

                                _node.index(index.name, index.key, index.value, function (err) {
                                    if (err) {
                                        //console.log('ERROR: Creating index error.');
                                        //console.log(err);
                                        //console.log('===================================================================');
                                    } else {
                                        //console.log(index);
                                    }
                                }, false);
                            });

                            //console.log('=========================================');
                        }
                    });
                }
            });

            return deferred.promise;
        };

        /**
         * Model's delete function Return success/error via promise.
         */
        _self.del = function () {
            var deferred = __Q.defer();

            //next tick so done and fail functions can be assigned
            process.nextTick(function () {
                if (_node === undefined) {
                    deferred.reject('Model first must be created before deleted.');
                } else {
                    _node.del(function (err) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            deferred.resolve();

                            //forse delete
                            //delete INDEXES !!!
                            //delete model instance
                        }
                    });
                }
            });

            return deferred.promise;
        };

        //here scheme must be looped and if user specified relationships methods must be added
        //model.getRelationships
        //model.addRelationship
        //model.removeRelationship

        /**
         * Create relationship methods
         */
        Object.keys(scheme).forEach(function (key) {
            //if there is and target ... this is an relationship
            var val = scheme[key],
                isRelationship = val.target && val.noun && val.plural;

            //if there is a target, noun and plural - it's relationship

            if (isRelationship) {
                //create methods for this relationship
                var getMethod = 'get' + val.plural[0].toUpperCase() + val.plural.slice(1),
                    addMethod = 'add' + val.noun[0].toUpperCase() + val.noun.slice(1),
                    removeMethod = 'remove' + val.noun[0].toUpperCase() + val.noun.slice(1);

                /**
                 * Getting related nodes
                 * TODO: DO FILTERING
                 * @param params
                 * @returns {Promise}
                 */
                _self[getMethod] = function (params) {
                    var deferred = __Q.defer();

                    node.getRelationshipNodes(val.type, function (err, nodes) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            var models = [];

                            nodes.forEach(function (node) {
                                models.push(new Model(node));
                            });

                            deferred.resolve(models);
                        }
                    });

                    //if params === undefined - get all
                    //if params !== undefined - filter by params

                    return deferred.promise;
                };

                /**
                 * Add relationship to a node
                 * @param endNodeId
                 */
                _self[addMethod] = function (endNodeId) {
                    var deferred = __Q.defer();

                    __neo4j.getNodeById(endNodeId, function (err, endNode) {
                        if (err) {
                            //console.log(err);
                            deferred.reject(err);
                        } else {

                            //Create relationship to end node
                            /**
                             * TODO: Do relationship data
                             */
                            var relationshipData = {};
                            _node.createRelationshipTo(endNode, val.type, relationshipData, function (err, relationship) {
                                if (err) {
                                    deferred.reject(err);
                                }

                                deferred.resolve();

                                //console.log('----------------------------------------');
                                //console.log('relationship:');
                                //console.log(relationship);
                                //console.log('----------------------------------------');
                            });
                        }
                    });

                    return deferred.promise;
                };

                /**
                 * Remove relationship to node
                 * @param endNodeId
                 */
                _self[removeMethod] = function (endNodeId) {
                    var deferred = __Q.defer(),
                        startNodeId = _id,
                        endNodeId = endNodeId,

                        relationshipType = val.type,
                        query = [
                            'START a=node(' + startNodeId + '), b=node(' + endNodeId + ')',
                            'MATCH a-[r:' + relationshipType + ']->b',
                            'DELETE r'
                        ].join('\n'),
                        params = {};

                    __neo4j.query(query, params, function (err, results) {
                        if (err) {
                            deferred.reject(err);
                        } else {
                            deferred.resolve(results);
                        }
                    });

                    return deferred.promise;
                };

            }

        });


        /**
         * Create properties setters and getters
         */
        Object.keys(scheme).forEach(function (key) {

            //if target is undefined the rule is NOT for relationship
            if (scheme[key].target === undefined) {

                /**
                 * type getter
                 */
                _self.__defineGetter__(key, function () {
                    return _data[key];
                });

                /**
                 * type setter
                 */
                _self.__defineSetter__(key, function (val) {
                    //validate before save

                    if (__validator.validateProperty(_type, key, val)) {
                        ;
                        _data[key] = val;
                    } else {
                        console.log("ERROR: Value is not valid.");
                    }
                });

            }

        });


        /**
         * Disable adding new functions and properties from the alter on.
         */
        Object.preventExtensions(this);


        /**
         * Set Values
         */

        if (newNode) {
            if (newNode.data) {
                _setData(newNode.data);
                _node = newNode;
            } else {
                console.log('Trow error no, node data.');
            }
        } else {
            console.log('Trow error no, node.');
        }


        /**
         * Set Indexes
         */
        Object.keys(scheme).forEach(function (key) {

            if (scheme[key].index) {
                var index = {
                    name: _type,
                    key: key,
                    value: _data[key]
                };

                _indexes.push(index);
            }
        });

        //add another index for node type
        var nodeIndex = {
            name: 'nodes',
            key: 'type',
            value: _type
        };

        _indexes.push(nodeIndex);
    };

    __models.registerModel(modelType, model, scheme);
    __schemes.registerModel(modelType, scheme);
    __db.registerModel(modelType, model, scheme);
};
