/**
 * created by: Nikolai Aleksandrenko
 * email: aleksandrenko@gmail.com
 * www: aleksandrenko.com
 */

"use strict";

var __neo4jApi = require('neo4j'),
    __neo4j = new __neo4jApi.GraphDatabase('http://localhost:7474'),
    __Q = require('q'),
    __models = require('./models.js');

module.exports = {
    /**
     * Executes cypher query against the neo4j rest api
     * @param {string} query
     * @param {object} params
     */
    query: function (query, params) {
        var deferred = __Q.defer();

        return deferred.promise;
    },

    /**
     * Registers model in the db amd creates methods like this:
     * db.user.getById, db.user.getAll, db.user.create(), db.user.getByUsername() //when username is a selected index
     * @param {object} new_model
     * @param {object} scheme
     */
    registerModel: function (modelType, NewModel, scheme) {

        if (this[modelType] === undefined) {
            var instance = {};

            /**
             * Return an instance of the requested model filled with the provided data
             * @param {Object} data - Initial data for the model (key:value)
             * @return {Object} - Returns instance of model
             */
            instance.create = function (data) {
                var newNode = __neo4j.createNode(data);
                return new NewModel(newNode);
            };

            /**
             * @param {number} id
             */
            instance.getById = function (id) {
                var deferred = __Q.defer();

                //next tick so done and fail functions can be assigned
                process.nextTick(function () {

                    __neo4j.getNodeById(id, function (err, node) {
                        if (err) {
                            deferred.reject(err);
                        } else {

                            var newModelInstance = new NewModel(node);
                            deferred.resolve(newModelInstance);

                            //delete INDEXES !!!
                            //delete model instance
                        }
                    });
                });

                return deferred.promise;
            };


            /**
             * Return instances of the model founded by the main key.
             */
            instance.getAll = function () {
                var deferred = __Q.defer(),
                    query = [
                        'START nodes=node:nodes(type="' + modelType + '")',
                        'RETURN nodes',
                        'ORDER BY ID(nodes) DESC'
                    ].join('\n'),
                    params = {};


                __neo4j.query(query, params, function (err, nodes) {

                    if (err) {
                        deferred.reject(err);
                    } else {

                        var models = [];

                        nodes.forEach(function (node) {
                            models.push(new NewModel(node.nodes));
                        });

                        deferred.resolve(models);

                    }
                });

                return deferred.promise;
            };

            // create function based on custom indexes in the scheme
            //model.getByUsername = function() {}
            //model.getByEmail = function() {}
            //
            // go through indexes
            //
            Object.keys(scheme).forEach(function (key) {
                var val = scheme[key];

                if (val.index) {
                    var getMethod = 'getBy' + key[0].toUpperCase() + key.slice(1);

                    /**
                     * New method for getting by index
                     * @param indexValue
                     */
                    instance[getMethod] = function (indexValue) {
                        var deferred = __Q.defer();

                        __neo4j.getIndexedNodes(modelType, key, indexValue, function (err, nodes) {
                            if (err) {
                                deferred.reject(err);
                            } else {

                                var Model = __models[modelType],
                                    models = [];

                                nodes.forEach(function (node) {
                                    models.push(new Model(node));
                                });

                                deferred.resolve(models);
                            }
                        });

                        //deferred.resolve(data);
                        //deferred.reject(err);

                        return deferred.promise;
                    };
                }
            });


            //add the new model to db
            this[modelType] = instance;
        }
    }

};
